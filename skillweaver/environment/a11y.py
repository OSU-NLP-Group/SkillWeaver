"""
NOTE: Some of this code is loosely adapted from the WebArena processing code:
- https://github.com/web-arena-x/webarena/blob/daee18de46d4b8e3c98c8cf5e5c4ef6de2f7a8eb/browser_env/processors.py.
"""
import asyncio
import os
import string
from typing import Optional, OrderedDict, TypedDict
from urllib.parse import parse_qsl, urlencode, urlparse
import tiktoken
from aioconsole import aprint
from playwright.async_api import Frame, Locator, Page, async_playwright
from typing_extensions import NotRequired

with open(os.path.dirname(__file__) + "/ts/_compiled.js", "r") as f:
    content = f.read()

class BoundingBox(TypedDict):
    x: float
    y: float
    width: float
    height: float

class LocatorPart(TypedDict):
    selector: str
    parameters: dict

class AXTree(TypedDict):
    id: int  # generated by us
    tag_name: str
    role: str
    name: str
    properties: dict
    bounding_box: BoundingBox
    children: list["AXTree"]
    locator_parts: list[LocatorPart]

class LocatorTree(TypedDict):
    locator: Locator
    children: list["LocatorTree"]

async def _is_injected(page: Page | Frame):
    return await page.evaluate("window.__webAgentDomInterface !== undefined")

async def _inject(page: Page | Frame):
    # This exposes the __webAgentDomInterface object as a property of `window`.
    await page.evaluate(f"(() => {{ {content} }})()")

def _attach_subtree(base: AXTree, subtree: AXTree, frame_name: str, frame_url: str):
    if (
        base["tag_name"] == "iframe"
        and base["properties"].get("name") == frame_name
        and base["properties"].get("url") == frame_url
    ):
        base["children"] = [subtree]

        return True
    else:
        for child in base["children"]:
            if _attach_subtree(child, subtree, frame_name, frame_url):
                break

    return False


# Recursive functions for arbitrary-length MCQ choice symbols.
def _generate_option_name(index: int):
    if index < 26:
        return string.ascii_uppercase[index]
    else:
        return (
            _generate_option_name(index // 26 - 1) + string.ascii_uppercase[index % 26]
        )


IGNORED_ACTREE_PROPERTIES = (
    "focusable",
    "editable",
    "readonly",
    "level",
    "settable",
    "multiline",
    "invalid",
)

NULL_TREE_FORMAT_RESULT = ("", {})


class ParsedAXNode(TypedDict):
    nodeId: str
    parent: NotRequired["ParsedAXNode"]
    role: str
    name: str
    children: list["ParsedAXNode"]
    properties: dict
    backendDOMNodeId: int


def _is_empty_inlinetextbox(node: ParsedAXNode | AXTree):
    return node["role"] == "InlineTextBox" and not node["name"]


def _is_interactable(node: ParsedAXNode | AXTree) -> bool:
    return node["role"] not in [
        "StaticText",
        "contentinfo",
        "navigation",
        "heading",
        "time",
        "generic",
        "main",
        "RootWebArea",
        "document",
    ]


def _unicode_repr(s) -> str:
    if type(s) is str:
        return '"' + s.replace("\n", "\\n").replace('"', '\\"') + '"'
    else:
        return repr(s)


tokenizer = tiktoken.encoding_for_model("gpt-4o")


def _is_like_natural_language(s: str):
    nchar = len(s)
    ntok = len(tokenizer.encode(s))
    return (nchar / ntok) > 3 or ntok <= 2


def _simplify_properties(properties: dict, base_url: str | None):
    """
    Simplifies the properties
    """

    transformed_properties = {**properties}
    if "url" in transformed_properties and type(transformed_properties["url"]) is str:
        if base_url is not None:
            if transformed_properties["url"].startswith(base_url):
                # Try to simplify the URL.
                transformed_properties["url"] = transformed_properties["url"][
                    len(base_url) :
                ]
            elif transformed_properties["url"].startswith("javascript:"):
                transformed_properties["url"] = "javascript:..."

        parsed = urlparse(transformed_properties["url"])
        queries = parse_qsl(parsed.query)
        queries_filtered = []
        for k, v in queries:
            if _is_like_natural_language(v):
                queries_filtered.append((k, v))

        new_query = urlencode(queries_filtered)
        new_url = parsed._replace(query=new_query).geturl()

        transformed_properties["url"] = new_url

    return transformed_properties


def filter_out_of_view_nodes(node: AXTree) -> AXTree | None:
    degenerate = (
        node["bounding_box"]["width"] == 0 and node["bounding_box"]["height"] == 0
    )
    x1 = node["bounding_box"]["x"]
    y1 = node["bounding_box"]["y"]
    x2 = x1 + node["bounding_box"]["width"]
    y2 = y1 + node["bounding_box"]["height"]
    height = 720
    width = 1280
    onscreen = not degenerate and ((y2 > 0 and y1 < height) and (x2 > 0 and x1 < width))

    # Check if any part is visible.
    new_children = []
    for child in node["children"]:
        filtered_child = filter_out_of_view_nodes(child)
        if filtered_child:
            new_children.append(filtered_child)

    if not onscreen and len(new_children) == 0 and node["role"] != "option":
        # This node, and none of its children, are visible.
        return None
    else:
        return {**node, "children": new_children}


def serialize_accessibility_tree(
    root: AXTree,
    *,
    add_mcq=False,
    element_counter=0,
    base_url=None,
    root_locator: Optional[Locator] = None,
    indent=0,
) -> tuple[str, dict[str, tuple[int, Optional[Locator]]]]:
    """
    Converts an accessibility tree DOM to a string.

    Parameters:
    - root: The root of the accessibility tree.
    - add_mcq: Whether to add multiple-choice question (MCQ) options to the string.
    - element_counter, indent: Helper parameters used for recursive cause.
    - root_locator: Used to generate Playwright locators for MCQ options.
    """

    if add_mcq:
        assert root_locator is not None, "Trying to use mcq without a root locator."

    if _is_empty_inlinetextbox(root):
        return NULL_TREE_FORMAT_RESULT

    if (
        root["role"] == "presentation"
        and len(root["children"]) == 0
        and not root["name"]
    ):
        return NULL_TREE_FORMAT_RESULT

    text = "  " * indent

    options: dict[str, tuple[int, Optional[Locator]]] = OrderedDict()
    if _is_interactable(root):
        option_name = _generate_option_name(element_counter)
        element_counter += 1
        options[option_name] = (root["id"], root_locator)

        if add_mcq:
            text += f"[{option_name}] "

    # Determine which accessible role to display.
    if root["role"] == "RootWebArea":
        role = "#document"
    elif root["role"] == "StaticText":
        role = "text"
    else:
        role = root["role"]

    text += role
    if root["name"]:
        text += f': {_unicode_repr(root["name"])}'

    # These properties have already been filtered.
    transformed_properties = _simplify_properties(root["properties"], base_url)
    props = []

    if root["tag_name"] == "select":
        props.append("[use .select_option(option_name) to interact]")

    for k, v in transformed_properties.items():
        if k.startswith("$"):
            continue
        elif k == "selected":
            if v:
                props.append("selected")
        else:
            if k == "disabled" and not v:
                continue
            if k == "expanded" and v == "none":
                continue
            if k == "level" and v == 0:
                continue
            if k == "pressed" and not v:
                continue
            if k == "checked" and not v:
                continue

            props.append(f"{k}: {_unicode_repr(v)}")

    props_text = ", ".join(props)
    if props_text:
        props_text = ", " + props_text

    text += props_text

    children_text = ""

    # Skip children of links that already have names.
    if not (root["role"] in ["link", "button", "image"] and root["name"]):
        select_options_shown = 0

        for i, child in enumerate(root["children"]):
            if child["role"] == "option":
                max_options = 100
                if select_options_shown < max_options:
                    select_options_shown += 1
                    if (
                        select_options_shown == max_options
                        and len(root["children"]) > max_options
                    ):
                        children_text += (
                            "\n"
                            + "  " * (indent + 1)
                            + "# ... (more options are not shown)"
                        )

                if select_options_shown >= max_options:
                    continue

            if root_locator is not None:
                child_locator = root_locator
                for locator_part in child["locator_parts"]:
                    parameters = dict(locator_part["parameters"])
                    if locator_part["selector"] == "get_by_role":
                        child_locator = child_locator.get_by_role(
                            parameters.pop("role"),
                            **parameters,
                            # include_hidden=True,
                        )
                    elif locator_part["selector"] == "nth":
                        child_locator = child_locator.nth(parameters.pop("index"))
            else:
                child_locator = None

            child_text, child_options = serialize_accessibility_tree(
                child,
                add_mcq=add_mcq,
                element_counter=element_counter,
                base_url=base_url,
                root_locator=child_locator,
                indent=indent + 1,
            )
            if len(child_options) == 0:
                # This node should not be included.
                # print("Skipping child because it has no interactable subnodes.")
                continue

            children_text += ("\n" if len(text) > 0 else "") + child_text
            options.update(child_options)
            element_counter += len(child_options)

    children_text = children_text.rstrip()
    if children_text:
        text += " {" + children_text + "\n" + "  " * indent + "};\n"
    else:
        # There were no real children
        if root["role"] == "iframe":
            return NULL_TREE_FORMAT_RESULT

        text += ";"

    return text, options


async def capture_accessibility_tree(page: Page | Frame) -> AXTree:
    if not await _is_injected(page):
        await _inject(page)

    top_level_tree = await page.evaluate(
        "window.__webAgentDomInterface.getAccessibilityTree()"
    )
    subframes = page.frames if isinstance(page, Page) else page.child_frames
    for frame in subframes:
        try:
            tree = await capture_accessibility_tree(frame)
        except Exception as e:
            if "Frame was detached" not in str(e):
                await aprint("Could not get tree for frame:", e)
            continue

        if not _attach_subtree(top_level_tree, tree, frame.name, frame.url):
            pass

    return top_level_tree


async def example():
    import nest_asyncio

    from skillweaver.environment import make_browser

    nest_asyncio.apply()

    async with async_playwright() as playwright:
        browser = await make_browser(playwright, "https://jetblue.com", headless=False)
        state = await browser.observe()
        await aprint(state.get_axtree_string())
        await browser.close()


if __name__ == "__main__":
    asyncio.run(example())
